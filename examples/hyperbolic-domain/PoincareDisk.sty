Global {
   scalar width = 800.0
   scalar height = 700.0
   scalar pointSize = width/100.0
   scalar thinStroke = width/200.0
   scalar planeSize = 0.9*height
}

Colors {
   color none = rgba(0.0, 0.0, 0.0, 0.0)
   color black = rgba( 0.0, 0.0, 0.0, 1.0 )
   color blue = rgba( 0.8, 0.7, 1.0, 0.2 )
   color red = rgba( 1.0, 0.0, 0.0, 0.5 )
}

forall HyperbolicPlane H {
   shape H.diskShape = Circle {
      center : (0.0, 0.)
      r : Global.planeSize/2.0
      color : Colors.blue
      strokeWidth : Global.thinStroke
      strokeColor : Colors.black
      strokeStyle : "dashed"
      strokeDashArray : "20,10,5,5,5,10"
   }
}

forall Point p; HyperbolicPlane H
where In( p, H ) {
   shape p.dotShape = Circle {
      r : Global.pointSize/2.0
      strokeWidth : 0.0
      color : Colors.red
   }

   layer p.dotShape above H.diskShape

   --ensure contains( H.diskShape, p.dotShape )
}

-- TODO: Fix that we can't add new functions with new names w/o backend complaining

forall IdealPoint p; HyperbolicPlane H
where In( p, H ) {
   scalar p.angle = ?

   scalar R = H.diskShape.r

   shape p.dotShape = Circle {
      center : R*(cos(p.angle), sin(p.angle))
      r : Global.pointSize
      strokeWidth : 0.0
      color : Colors.black
   }
}

forall Horocycle h; HyperbolicPlane H {
  shape h.circleShape = Circle {
    color : Colors.none
    strokeWidth : 2.0
    strokeColor : Colors.black
  }

  scalar R = H.diskShape.r

  ensure inRange(h.circleShape.r, R/8., R/2.)
  constraint h.inDisk      = ensure contains(H.diskShape, h.circleShape)
  constraint h.tangentDisk = ensure tangentTo(H.diskShape, h.circleShape)
}

forall IdealPoint p; Horocycle h; HyperbolicPlane H
where IsCenter( p, h ); In( p, H ) {

   scalar R = H.diskShape.r
   scalar r = h.circleShape.r
   vec2 x = p.dotShape.center

   -- -- set the center of the horocycle h so that it is
   -- -- tangent to the hyperbolic plane H at ideal point p
   scalar a = R - r
   h.circleShape.center = a*unit(x)

   -- since we've computed the location of the center
   -- explicitly, we should no longer need constraints to
   -- ensure containment/tangency in the Poincar√© disk
   delete h.inDisk
   delete h.tangentDisk
}

-- default "constructor"
forall Geodesic g; HyperbolicPlane H
{
   g.shape = Circle{}

   constraint g.diskConstraint = ensure orthogonalCircles( g.shape, H.diskShape )
}

forall Geodesic g; IdealPoint p; IdealPoint q; HyperbolicPlane H
where g := MakeGeodesic( p, q )
{
   vec2 P = p.dotShape.center
   vec2 Q = q.dotShape.center
   scalar theta = angleBetween( P, Q )
   scalar L = H.diskShape.r
   scalar R = L/cos(theta/2.)
   vec2 c = R*unit(P+Q)
   scalar r = norm(c - P)

   g.shape = Circle {
      center: c
      r: r
   }

   -- g.shape = Line {
   --        start: p.dotShape.center
   --          end: q.dotShape.center
   --        color: Colors.black
   --    thickness: 5.
   -- }

   delete g.diskConstraint

   layer p.dotShape above g.shape
   layer q.dotShape above g.shape
}

forall Geodesic g; Geodesic h; IdealPoint p; HyperbolicPlane H
where PerpendicularAt( g, h, p ); In( p, H )
{
   vec2 P = p.dotShape.center
   vec2 Cg = g.shape.center
   vec2 Ch = h.shape.center
   scalar Rg = g.shape.r

   -- ensure that g passes through p
   ensure equalTo( Rg, norm( Cg - P ))

   -- also ensure that g and h are orthogonal
   ensure orthogonalCircles( g.shape, h.shape )
}

IdealPoint `pi`
{
   override `pi`.angle = 0.0
}

IdealPoint `pj`
{
   override `pj`.angle = 2.0*3.1415926/3.0
}

IdealPoint `pk`
{
   override `pk`.angle = 4.0*3.1415926/3.0
}
