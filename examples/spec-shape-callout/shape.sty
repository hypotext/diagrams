global {
       nodeR = 6.

       lineThickness = 3.

       calloutPadding = 30. -- Padding around the text for rect
       calloutThickness = 30. -- Thickness of base of stem
       calloutEndPadding = 40. -- Space between the external anchor point and the stem
       maxCalloutDist = 200.
}

colors {
       black = rgba(0., 0., 0., 1.)
       red = rgba(1., 0., 0., 1.)
       green = rgba(0., 1., 0., 1.)
       blue = rgba(0., 0., 1., 1.)
       none = rgba(0., 0., 0., 0.)
}

Node n {
     n.shape = Circle { 
             r: global.nodeR
             strokeWidth: 0.
             color: colors.black
             center: (0., 0.)
     }

     n.text = Text {
            center: (100., 100.)
            string: n.label
     }

     n.callout = Rectangle {
               strokeWidth: global.lineThickness
               strokeColor: colors.black
               color: colors.none
               center: n.text.center
               w: n.text.w + global.calloutPadding
               h: n.text.h + global.calloutPadding
     }

     -- Parallel to callout direction
     vec = normalize(n.callout.center - n.shape.center)

     n.anchorStart = n.shape.center + global.calloutEndPadding * vec

     -- Thick line
     n.line = Line {
            start: n.anchorStart
            end: n.callout.center
            thickness: global.calloutThickness
            color: rgba(0.5, 0.5, 0.5, 0.5)
     }

     -- TODO: add rounded corners for rectangles -- rx, ry

     -- Thin line
     n.line1 = Line {
             start: n.anchorStart
             end: n.callout.center
             thickness: global.lineThickness
             color: colors.black
     }

     n.line1 above n.line

     -- Perpendicular location - start of segment
     segStart = n.anchorStart + global.calloutThickness / 2. * rot90(vec)
     n.circle1 = Circle {
               color: colors.red
               r: 5.
               strokeWidth: 0.
               center: segStart
     }

     -- Seg endpt
     t = norm(n.callout.center - n.anchorStart)
     segEnd = segStart + t * vec

     n.circle2 = Circle {
               color: colors.red
               r: 5.
               strokeWidth: 0.
               center: segEnd
     }

     -- hit point 1
     n.circle3 = Circle {
               color: colors.blue
               r: 5.
               strokeWidth: 0.
               -- center: 
     }

     -- TODO: Draw lines from anchorStart to the intersection point of the +/- normal points with the relevant line segment of the rectangle

      -- TODO: Encode this as a new shape - https://docs.google.com/document/d/1OwAbazADJhqzWRQ_3_Jll58xaLjvbqNxoaxCGo33tRU/edit

     dist = norm(n.callout.center - n.shape.center)
     -- TODO: dist should include dimension of rectangle
     ensure lessThan(dist, 200.)

     -- Not working so well? TODO
     -- ensure disjoint(n.callout, n.shape)

     calloutPoints = makeCallout(n.text.center, n.text.w, n.text.h, n.shape.center, global.calloutPadding, global.calloutThickness, global.calloutEndPadding)
     n.calloutShape = Path {
                    -- pathData: pathFromPoints("closed", [(0., 0.), (100., 100.), (200., 0.), (0., 0.)])
                    pathData: pathFromPoints("closed", calloutPoints)
                    strokeWidth: 5.0
                    color: colors.blue
     }
}

-- TODO: Note that units are in pixels for the current renderers